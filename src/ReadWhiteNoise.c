/*****************************************************************
 *                        PINOCCHIO  V4.1                        *
 *  (PINpointing Orbit-Crossing Collapsed HIerarchical Objects)  *
 *****************************************************************
 
 This code was written by
 Pierluigi Monaco
 Copyright (C) 2016
 
 web page: http://adlibitum.oats.inaf.it/monaco/pinocchio.html
 
 This program is free software; you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation; either version 2 of the License, or
 (at your option) any later version.
 
 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 
 You should have received a copy of the GNU General Public License
 along with this program; if not, write to the Free Software
 Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*/

#include "pinocchio.h"

/* This routine reads in a white noise field as generated by GRAFIC2 
   and adds the correct power */

#ifdef WHITENOISE

int read_white_noise()
{
  int dummy,np1,np2,np3,seed,Ninplane,gz,lx,ly,lz,Task,i;
  int local_x,local_y,local_z,ixx,iyy,izz,index,nxhalf,nyhalf,nzhalf;
  size_t planesize;
  float *plane;
  double kx,ky,kz,kxnorm,kynorm,kznorm,k_squared,k_module,k_physical,time,norm,delta;
  double ave=0.0, var=0.0, gave, gvar;
  char filename[LBLENGTH];
  FILE *file;
  MPI_Status status;

  Ninplane=MyGrids[0].GSglobal_x * MyGrids[0].GSglobal_y;
  planesize=Ninplane * sizeof(float);
  plane=(float*)malloc(planesize);

  if (!ThisTask)
    {
      strcpy(filename,"WhiteNoise");
      file=fopen(filename,"r");
      if (file==0x0)
	{
	  printf("ERROR on Task 0: cannot find file WhiteNoise required by read_white_noise\n");
	  return 1;
	}

      fread(&dummy, 1, sizeof(int), file);
      fread(&np1, 1, sizeof(int), file);
      fread(&np2, 1, sizeof(int), file);
      fread(&np3, 1, sizeof(int), file);
      fread(&seed, 1, sizeof(int), file);
      fread(&dummy, 1, sizeof(int), file);

      if (np1 != MyGrids[0].GSglobal_x || np2 != MyGrids[0].GSglobal_y || np3 != MyGrids[0].GSglobal_z)
	{
	  printf("ERROR on Task 0: WhiteNoise file has wrong dimensions: %d %d %d\n",np1,np2,np3);
	  return 1;
	}
    }

  for (gz=0; gz<MyGrids[0].GSglobal_z; gz++)
    {
      /* Task 0 reads the plane */
      if (!ThisTask)
	{
	  fread(&dummy,1,sizeof(int),file);
	  if (dummy != planesize)
	    {
	      printf("ERROR on Task 0: mis-matched record size for file WhiteNoise, I expected %d but obtained %d\n",
		     (int)planesize, dummy);
	      return 1;
	    }

	  fread(plane, Ninplane, sizeof(float), file);
	  fread(&dummy,1,sizeof(int),file);

	  printf("Task 0 has read plane %d\n",gz);
	}

      /* each task writes into an int variable either 0 or its task number if the plane belongs to it */     
      if (gz>=MyGrids[0].GSstart_z && gz<MyGrids[0].GSstart_z + MyGrids[0].GSlocal_z)
	dummy=ThisTask;
      else
	dummy=0;

      /* This way the variable Task (for Task 0) contains the task that must receive the plane */
      MPI_Reduce(&dummy, &Task, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);

      if (!ThisTask)  /* Task 0 either stores the data or sends them to Task */
	{
	  printf("The plane will be stored by Task %d\n",Task);

	  if (Task)
	    MPI_Send(plane, planesize, MPI_BYTE, Task, 0, MPI_COMM_WORLD);
	  else
	    {
	      for (i=0; i<Ninplane; i++)
		{
		  ave+=plane[i];
		  var+=plane[i]*plane[i];
		}
	      lz=gz-MyGrids[0].GSstart_z;
	      for (ly=0; ly<MyGrids[0].GSlocal_y; ly++)
		for (lx=0; lx<MyGrids[0].GSlocal_x; lx++)
		  *(rvector_fft[0] + lx + (MyGrids[0].GSlocal_x + MyGrids[0].off) * (ly + lz * MyGrids[0].GSlocal_y)) =
		    *(plane + lx + MyGrids[0].GSlocal_x * ly);
		    
	    }
	}
      else     /* other tasks receive the data and store them if dummy>0 */
	{
	  if (dummy==ThisTask)
	    {
	      MPI_Recv(plane, planesize, MPI_BYTE, 0, 0, MPI_COMM_WORLD, &status);
	      for (i=0; i<Ninplane; i++)
		{
		  ave+=plane[i];
		  var+=plane[i]*plane[i];
		}
	      lz=gz-MyGrids[0].GSstart_z;
	      for (ly=0; ly<MyGrids[0].GSlocal_y; ly++)
		for (lx=0; lx<MyGrids[0].GSlocal_x; lx++)
		  *(rvector_fft[0] + lx + (MyGrids[0].GSlocal_x + MyGrids[0].off) * (ly + lz * MyGrids[0].GSlocal_y)) =
		    *(plane + lx + MyGrids[0].GSlocal_x * ly);
	    }
	}
    }

  MPI_Reduce(&ave, &gave, 1, MPI_DOUBLE, MPI_SUM, 0, MPI_COMM_WORLD);
  MPI_Reduce(&var, &gvar, 1, MPI_DOUBLE, MPI_SUM, 0, MPI_COMM_WORLD);
  if (!ThisTask)
    {
      gave /= (double)MyGrids[0].GSglobal_x*(double)MyGrids[0].GSglobal_y*(double)MyGrids[0].GSglobal_z;
      gvar = sqrt(gvar/((double)MyGrids[0].GSglobal_x*(double)MyGrids[0].GSglobal_y*(double)MyGrids[0].GSglobal_z));
      printf("Average and variance of white noise: %f, %f\n",gave,gvar);
    }

  free(plane);


  if (!ThisTask)
    printf("[%s] read_white_noise: starting fft\n",fdate());

  time = forward_transform(0);

  if (!ThisTask)
    printf("[%s] read_white_noise: done fft, cputime = %f\n",fdate(),time);

  cputime.fft+=time;


  /* loop on the cvector to fix the power spectrum */
  /* k vectors */
  kxnorm   = 2.*PI/(double)MyGrids[0].GSglobal_x;
  kynorm   = 2.*PI/(double)MyGrids[0].GSglobal_y;
  kznorm   = 2.*PI/(double)MyGrids[0].GSglobal_z;

  /* Nyquist frequencies */
  nxhalf = MyGrids[0].GSglobal_x/2;
  nyhalf = MyGrids[0].GSglobal_y/2;
  nzhalf = MyGrids[0].GSglobal_z/2;

  norm = 1.0/pow(params.InterPartDist, 3.0);

  for (local_z = 0; local_z < MyGrids[0].GSlocal_k_z; local_z++)
    {
      izz = local_z + MyGrids[0].GSstart_k_z;
      if (local_z > nzhalf)
	izz -= MyGrids[0].GSglobal_z;
      kz  = kznorm*izz;

      for (local_y = 0; local_y < MyGrids[0].GSlocal_k_y; local_y++)
	{
	  iyy = local_y + MyGrids[0].GSstart_k_y;
	  if (iyy > nyhalf)
	    iyy -= MyGrids[0].GSglobal_y;
	  ky  = kynorm*iyy;

	  for (local_x = 0; local_x <= nxhalf; local_x++)
	    {
	      ixx = local_x;
	      kx  = kxnorm*ixx;

              k_squared  = kx*kx + ky*ky + kz*kz;
	      k_module   = sqrt(k_squared);
	      k_physical = k_module / params.InterPartDist;

	      /* corresponding index of real part in vector (imaginary in index + 1) */
	      index = 1 + 2*local_x + (MyGrids[0].GSglobal_x+MyGrids[0].off)
		*(local_z + local_y* MyGrids[0].GSglobal_z);

	      if (k_squared > 0)
		delta = sqrt(norm * PowerSpectrum(k_physical) * 
			     exp(-pow(k_module/MyGrids[0].upper_k_cutoff,16.0) ) );
	      else
		delta = 0.0;
		
	      (cvector_fft[0][index/2])[0] *= delta;
	      (cvector_fft[0][index/2])[1] *= delta;

	    }
	}
    }

  write_from_cvector(0,kdensity[0]);

  return 0;

}

#endif
